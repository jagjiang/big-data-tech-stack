###代理模式
easy包中在客户端和Person类之间新增了一个中间件PersonProxy,这个类就叫做代理类，它实现了和Person类一模一样的行为。

**代理模式** 给某一个对象提供一个代理，并由代理对象控制对原对象的引用。

static包为代理模式的一个应用，除了 打印日志，它还可以用来做用来做**权限管理**。看起来和装饰模式一模一样，但两者的目的不同，装饰模式是为了**增强功能或者添加功能**，代理模式主要为了**加以控制**

###动态代理
动态代理和静态代理的原理一模一样，只是换了一种写法。使用动态代理，需要把一个类传入，然后根据它正在调用的方法名判断是否加以控制。

实现的唯一难点是**怎么让httpUtil调用任意方法时，都通过一个方法间接调用**，这里需要用到反射技术，不了解反射技术也没关系，不妨把它记作固定的写法。

getInstance方法，Proxy.newProxyInstance方法是Java系统提供的方法，专门用于动态代理。其中传入的第一个参数是被代理的类的ClassLoader,第二个参数是被代理类的Interfaces,这两个参数都是Object中的，每个类都有，这里就是固定写法。我们只要知道系统需要这两个参数才能让我们实现目的：**调用被代理类的任意方法时，都通过一个方法间接调用**。现在我们给系统提供了这两个参数，系统就好在第三个参数中帮我们实现这个目的。
第三个参数是InvocationHandler接口，这个接口中只有一个方法:
```java
public Object invoke(Object proxy,Method method,Object[] args) throws Throwable;
```
动态代理本质上与静态代理没有区别，好处是**节省代码**。比如被代理类有20个方法，而我们只需要控制其中两个方法，就可以用动态代理通过方法名对被代理类进行动态的控制，而如果用静态方法，我们就要将另外18个方法也写出来。